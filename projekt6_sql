CREATE TABLE IF NOT EXISTS schema_pasula.intersects AS  
SELECT a.rast, b.municipality 
FROM rasters.dem AS a, vectors.porto_parishes AS b  
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality ilike 'porto';

ALTER TABLE schema_pasula.intersects
ADD COLUMN rid SERIAL PRIMARY KEY;

CREATE INDEX idx_intersects_rast_gist ON schema_pasula.intersects
USING gist (ST_ConvexHull(rast));

SELECT AddRasterConstraints('schema_pasula'::name, 'intersects'::name,'rast'::name);

--Przykład 1 - ST_Intersects Przecięcie rastra z wektorem.
CREATE TABLE schema_pasula.intersects AS
SELECT a.rast, b.municipality
FROM rasters.dem AS a, vectors.porto_parishes AS b
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality ilike 'porto';

ALTER TABLE schema_pasula.intersects
ADD COLUMN rid SERIAL PRIMARY KEY;

CREATE INDEX idx_intersects_rast_gist ON schema_pasula.intersects
USING gist (ST_ConvexHull(rast));


SELECT AddRasterConstraints('schema_pasula'::name,
'intersects'::name,'rast'::name);


-- 2 Obcinanie rastra na podstawie wektor
CREATE TABLE schema_pasula.clip AS
SELECT ST_Clip(a.rast, b.geom, true) AS rast, b.municipality AS municipality
FROM rasters.dem AS a, vectors.porto_parishes AS b
WHERE ST_Intersects(a.rast, b.geom) AND b.municipality like 'PORTO';

ALTER TABLE schema_pasula.clip
ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_clip_rast_gist ON schema_pasula.clip
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'clip'::name,'rast'::name);

CREATE TABLE schema_pasula.union AS
SELECT ST_Union(ST_Clip(a.rast, b.geom, true)) AS rast
FROM rasters.dem AS a, vectors.porto_parishes AS b
WHERE b.municipality ilike 'porto' AND ST_Intersects(b.geom,a.rast);

ALTER TABLE schema_pasula.union
ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_union_rast_gist ON schema_pasula.union
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'union'::name,'rast'::name);


--Tworzenie rastrów z wektorów (rastrowanie)


CREATE TABLE schema_pasula.porto_parishes_raster AS
WITH r AS (
SELECT rast FROM rasters.dem
LIMIT 1
)
SELECT ST_AsRaster(a.geom, r.rast, '8BUI', a.id, -32767) AS rast
FROM vectors.porto_parishes AS a, r
WHERE a.municipality ilike 'porto';

ALTER TABLE schema_pasula.porto_parishes_raster
ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_parishes_raster_gist ON schema_pasula.porto_parishes_raster
USING gist (ST_ConvexHull(rast));

SELECT AddRasterConstraints('schema_pasula'::name,
'porto_parishes_raster'::name, 'rast'::name);

CREATE TABLE schema_pasula.porto_parishes_union AS
WITH r AS (
SELECT rast FROM rasters.dem
LIMIT 1
)
SELECT st_union(ST_AsRaster(a.geom, r.rast, '8BUI', a.id, -32767)) AS rast
FROM vectors.porto_parishes AS a, r
WHERE a.municipality ilike 'porto';


ALTER TABLE schema_pasula.porto_parishes_union
ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_parishes_union_rast_gist ON schema_pasula.porto_parishes_union
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'porto_parishes_union'::name, 'rast'::name);


DROP TABLE IF EXISTS schema_pasula.porto_parishes_tiled;

CREATE TABLE schema_pasula.porto_parishes_tiled AS
WITH r AS (
SELECT rast FROM rasters.dem
LIMIT 1
)
SELECT st_tile(st_union(ST_AsRaster(a.geom,r.rast,'8BUI',a.id, -32767)), 128, 128, true, -32767) AS rast
FROM vectors.porto_parishes AS a, r
WHERE a.municipality ilike 'porto';

ALTER TABLE schema_pasula.porto_parishes_tiled
ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_parishes_tiled_rast_gist ON schema_pasula.porto_parishes_tiled
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'porto_parishes_tiled'::name, 'rast'::name);

--Konwertowanie rastrów na wektory 


--Przykład 1 - ST_Intersection
CREATE TABLE schema_pasula.intersection AS
SELECT
a.rid,
(ST_Intersection(b.geom, a.rast)).geom,
(ST_Intersection(b.geom, a.rast)).val
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
WHERE b.parish ilike 'paranhos' AND ST_Intersects(b.geom, a.rast);


CREATE TABLE schema_pasula.dumppolygons AS
SELECT
a.rid,
(ST_DumpAsPolygons(ST_Clip(a.rast,b.geom))).geom,
(ST_DumpAsPolygons(ST_Clip(a.rast,b.geom))).val
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
WHERE b.parish ilike 'paranhos' AND ST_Intersects(b.geom,a.rast);

CREATE INDEX idx_dumppolygons_geom_gist ON schema_pasula.dumppolygons
USING gist (geom);


--Analiza rastrow


CREATE TABLE schema_pasula.landsat_nir AS
SELECT rid, ST_Band(rast, 4) AS rast
FROM rasters.landsat8;
CREATE TABLE schema_pasula.paranhos_dem AS
SELECT a.rid, ST_Clip(a.rast, b.geom, true) AS rast
FROM rasters.dem AS a, vectors.porto_parishes AS b
WHERE b.parish ilike 'paranhos' AND ST_Intersects(b.geom, a.rast);

CREATE TABLE schema_pasula.paranhos_slope AS
SELECT a.rid, ST_Slope(a.rast, 1, '32BF', 'PERCENTAGE') AS rast
FROM schema_pasula.paranhos_dem AS a;

CREATE TABLE schema_pasula.paranhos_slope_reclass AS
SELECT a.rid, ST_Reclass(a.rast, 1, ']0-15]:1, (15-30]:2, (30-9999:3', '32BF', 0) AS rast
FROM schema_pasula.paranhos_slope AS a;

SELECT st_summarystats(ST_Union(a.rast)) AS total_stats
FROM schema_pasula.paranhos_dem AS a;
WITH t AS (
    SELECT st_summarystats(ST_Union(a.rast)) AS stats
    FROM schema_pasula.paranhos_dem AS a
)
SELECT (stats).min, (stats).max, (stats).mean FROM t;
WITH t AS (
    SELECT b.parish AS parish,
           st_summarystats(ST_Union(ST_Clip(a.rast, b.geom, true))) AS stats
    FROM rasters.dem AS a, vectors.porto_parishes AS b
    WHERE b.municipality ilike 'porto' AND ST_Intersects(b.geom, a.rast)
    GROUP BY b.parish
)
SELECT parish, (stats).min, (stats).max, (stats).mean FROM t;

-- ST_SummaryStats
SELECT st_summarystats(a.rast) AS stats
FROM schema_pasula.paranhos_dem AS a
LIMIT 1; 
SELECT
    b.name,
    st_value(a.rast, (ST_Dump(b.geom)).geom) AS elevation
FROM
    rasters.dem a,
    vectors.places AS b
WHERE
    ST_Intersects(a.rast, b.geom)
ORDER BY
    b.name;


--TPI


BEGIN;

DROP TABLE IF EXISTS schema_pasula.tpi30;

CREATE TABLE schema_pasula.tpi30 AS
SELECT ST_TPI(a.rast, 1) AS rast
FROM rasters.dem a;

-- Optymalizacja TPI (cały obszar)
ALTER TABLE schema_pasula.tpi30 ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_tpi30_rast_gist ON schema_pasula.tpi30
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'tpi30'::name, 'rast'::name);

-- 2. Obliczenie TPI ZOPTYMALIZOWANE-- Oblicza TPI tylko dla gminy Porto

DROP TABLE IF EXISTS schema_pasula.porto_tpi30;

CREATE TABLE schema_pasula.porto_tpi30 AS
SELECT ST_TPI(a.rast, 1) AS rast
FROM rasters.dem AS a, vectors.porto_parishes AS b
WHERE ST_Intersects(a.rast, b.geom)
  AND b.municipality ilike 'porto';

-- Optymalizacja TPI 
ALTER TABLE schema_pasula.porto_tpi30 ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_porto_tpi30_rast_gist ON schema_pasula.porto_tpi30
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'porto_tpi30'::name, 'rast'::name);

COMMIT;



--Przykład 1 Algebry Map
BEGIN;

DROP TABLE IF EXISTS schema_pasula.porto_ndvi;


CREATE TABLE schema_pasula.porto_ndvi AS
WITH r AS (
    -- Przyciecie Landsat8 
    SELECT a.rid, ST_Clip(a.rast, b.geom, true) AS rast
    FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
    WHERE b.municipality ilike 'porto' AND ST_Intersects(b.geom,a.rast)
)
SELECT
    r.rid,
    ST_MapAlgebra(
        r.rast, 1,
        r.rast, 4,
        '([rast2.val] - [rast1.val]) / ([rast2.val] + [rast1.val])::float',
        '32BF'
    ) AS rast
FROM r;

ALTER TABLE schema_pasula.porto_ndvi ADD COLUMN rid SERIAL PRIMARY KEY;
CREATE INDEX idx_porto_ndvi_rast_gist ON schema_pasula.porto_ndvi
USING gist (ST_ConvexHull(rast));
SELECT AddRasterConstraints('schema_pasula'::name,
'porto_ndvi'::name,'rast'::name);

COMMIT;


--Przykład 2 funkcja zwrotna

CREATE OR REPLACE FUNCTION sschema_pasula.ndvi(
    value double precision [] [] [],
    pos integer [][],
    VARIADIC userargs text []
)
RETURNS double precision AS
$$
BEGIN
-- value [1][1][1]: wartość piksela z pierwszego pasma wejściowego (Pasmo 1)
-- value [2][1][1]: wartość piksela z drugiego pasma wejściowego (Pasmo 4)
    RETURN (value [2][1][1] - value [1][1][1]) / (value [2][1][1] + value [1][1][1]);
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE COST 1000;

CREATE TABLE schema_pasula.porto_ndvi2 AS
WITH r AS (
SELECT a.rid,ST_Clip(a.rast, b.geom,true) AS rast
FROM rasters.landsat8 AS a, vectors.porto_parishes AS b
WHERE b.municipality ilike 'porto' and ST_Intersects(b.geom,a.rast)
)
SELECT
r.rid,ST_MapAlgebra(
r.rast,
ARRAY[1,4]::integer[],-- Tablica indeksów pasm: [1] i [4]
'schema_pasula.ndvi(double precision[], integer[], text[])'::regprocedure,
'32BF'::text
) AS rast
FROM r;


CREATE INDEX idx_porto_ndvi2_rast_gist ON schema_pasula.porto_ndvi2
USING gist (ST_ConvexHull(rast));

SELECT AddRasterConstraints('schema_pasula'::name, 'porto_ndvi2'::name, 'rast'::name);


--eksport rastrow 


SELECT ST_AsTiff(ST_Union(rast))
FROM schema_pasula.porto_ndvi2;

SELECT ST_AsGDALRaster(ST_Union(rast), 'GTiff', ARRAY['COMPRESS=DEFLATE',
'PREDICTOR=2', 'PZLEVEL=9'])
FROM schema_pasula.porto_ndvi2;



CREATE TABLE tmp_out AS
SELECT lo_from_bytea(0,
    ST_AsGDALRaster(ST_Union(rast), 'GTiff',  ARRAY['COMPRESS=DEFLATE',
    'PREDICTOR=2', 'PZLEVEL=9'])
) AS loid
FROM schema_pasula.porto_ndvi2;

SELECT lo_export(loid, 'C:\sem_5\Bazy_Danych_Przestrzennych\myraster.tiff')
FROM tmp_out;

SELECT lo_unlink(loid)
FROM tmp_out;

CREATE TABLE schema_pasula.tpi30_porto AS
SELECT ST_TPI(a.rast, 1) AS rast
FROM rasters.dem AS a
JOIN vectors.porto_parishes AS b
ON ST_Intersects(a.rast, b.geom)
WHERE b.municipality ILIKE 'porto';

CREATE INDEX idx_tpi30_porto_rast_gist ON schema_pasula.tpi30_porto
USING gist (ST_ConvexHull(rast));

SELECT AddRasterConstraints('schema_pasula'::name, 'tpi30_porto'::name, 'rast'::name);

